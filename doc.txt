source install/setup.sh
ros2 run xline_base_controller base_controller_node

colcon build
source install/setup.sh
ros2 run xline_inkjet_printer inkjet_printer_node

 colcon build --packages-select xline_msgs

ros2 service call /motion_control/execute_calibration std_srvs/srv/Trigger


手动清除 PATH 中的虚拟环境
# 从 PATH 中移除虚拟环境路径
export PATH=$(echo $PATH | tr ':' '\n' | grep -v venv | tr '\n' ':' | sed 's/:$//')
# 取消虚拟环境相关的环境变量
unset VIRTUAL_ENV
unset PYTHONHOME
# 验证
which python3
# 应该显示: /usr/bin/python3



1b 02 00 15 7b224555324c223a7b226e6f69736573223a317d7d  {"EU2L":{"noises":1}}
1b 02 00 19 7b224555324c223a7b2273657475704576656e74223a307d7d  {"EU2L":{"setupEvent":0}}

现在的需求是需要给tcp发送指令


1、不需要“连接统计模块”

2、对于协议层,实际数据示例如下：
这是第一条示例：1b 02 00 15 7b224555324c223a7b226e6f69736573223a317d7d -> (1b 02)是固定开头，（00）是可变喷码机编号，（15）是该条信息对应的指令，（7b224555324c223a7b226e6f69736573223a317d7d）是JSON格式的命令{"EU2L":{"noises":1}}转码后的数据
这是第二条示例：1b 02 00 19 7b224555324c223a7b2273657475704576656e74223a307d7d ->  (1b 02)是固定开头，（00）是可变喷码机编号，（19）是该条信息对应的指令，（7b224555324c223a7b226e6f69736573223a317d7d）是JSON格式的命令{"EU2L":{"setupEvent":0}}转码后的数据

3、详细分析实际示例，帮我重新设计协议层
4、如果我没有明确说明,都不需要主动编译代码，除非我显式说明

  分解：
  ┌─────────┬──────────┬──────────┬────────────────────────────────────────┐
    1B 02      00        15     7b224555324c223a7b226e6f69736573...  
   帧头     设备号    指令码    JSON数据（ASCII编码）                  
   2字节    1字节     1字节     变长                                   
  └─────────┴──────────┴──────────┴────────────────────────────────────────┘


    发送命令示例

  1. 使用指令名称
  source install/setup.sh
  ros2 service call /printer/send_command xline_msgs/srv/PrinterCommand \
    "{printer_name: 'printer_center', command: 'NOISES', json_data: '{\"EU2L\":{\"noises\":1}}'}"

  ros2 service call /printer/send_command xline_msgs/srv/PrinterCommand \
    "{printer_name: 'printer_center', command: 'SETUP_EVENT', json_data: '{\"EU2L\":{\"setupEvent\":1}}'}"

  ros2 service call /printer/send_command xline_msgs/srv/PrinterCommand \
    "{printer_name: 'printer_center', command: 'SETUP_EVENT', json_data: '{\"EU2L\":{\"setupEvent\":0}}'}"

  2. 使用十六进制指令码

  ros2 service call /printer_left/send_command xline_msgs/srv/PrinterCommand \
    "{command: '0x15', json_data: '{\"EU2L\":{\"noises\":1}}'}"

  3. 使用十进制指令码

  ros2 service call /printer_left/send_command xline_msgs/srv/PrinterCommand \
    "{command: '21', json_data: '{\"EU2L\":{\"noises\":1}}'}"

  4. 发送 SETUP_EVENT 命令

  ros2 service call /printer_center/send_command xline_msgs/srv/PrinterCommand \
    "{command: 'SETUP_EVENT', json_data: '{\"EU2L\":{\"setupEvent\":0}}'}"



如果不是特别说明，无需编译，无需编写测试代码，无需编写文档


  建议下一步：
  我可以帮您实施以下改进（按优先级）：
  1. 启用协议解析
  2. 简化服务接口（删除冗余）
  3. 添加常用指令的便捷方法

[DEBUG] 发送命令(8字节): 1B 02 00 26 01 1B 03 9E  [命令ID=0x26]
[DEBUG] 接收到响应数据(9字节): 1B 06 00 12 26 62 1B 03 27 

现在还有一个需求是，需要分别查询墨盒的模量，但是查询墨盒模量时使用的是另外一个端口8010（IP地址相同），需要发送的指令统一是：1B 02 00 26 01 1B 03 9E；服务端回码是：1B 06 00 12 26 62 1B 03 27，其中62所在的位置代表模量。现在需要你将该功能添加到快捷指令中，深度思考，使用最佳的方式实现
服务 → ROS 2 参数 → 参数回调 → 控制连接 → [可选]持久化到yaml
enabled
 比 enabled 
现在有一个需求是：需要添加一个启用/禁用喷码机的开关，这个开关不是用来控制是否连接到喷码机，而是用来比如如果禁用了，那就不允许给喷码机发送指令哪怕现在喷码机处于连接状态，我的想法是添加多一个参数enabled，然后在src/xline_msgs新增一个服务类型，
enabled要像auto_connect那样也需要持久化到文件src/xline_inkjet_printer/xline_inkjet_printer/config/printers.yaml中。先详细分析我的需求，然后实现


    {                                                       
      "id": 1,                                              
      "type": "line",                                       
      "ink": {                                              
        "enabled": true,                                    
        "mode": "solid" | "dashed" | "text",               
        "printer": "center" | "left" | "right"                     
      }                                                     
    }  

    {
      "color": "#D3D3D3",
      "end": {
        "x": -1003.8460303073251,
        "y": 626.8985882246766
      },
      "hidden": false,
      "id": 1000000,
      "ink": {
        "enabled": false,
        "mode": "solid",
        "printer": "center"
      },
      "layer": "TRANSITION",
      "layer_id": 1000000,
      "line_type": "",
      "opacity": 0.5,
      "order": 1,
      "printed": false,
      "selected": false,
      "start": {
        "x": -1043.3972714137565,
        "y": 587.253924940167
      },
      "thickness": 1.0,
      "type": "line",
      "work": false
    }

好的！我现在结合最新的action数据结构，在 MotionControlCenter 中集成 InkjetController。我注意到实际的 JSON 格式中 ink 字段使用的是 printer（单数），而不是 printers（复数）。
